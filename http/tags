!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
CaseInsensitiveLess	http.h	/^struct CaseInsensitiveLess {$/;"	s	namespace:sylar::http
CharsToHttpMethod	http.cc	/^HttpMethod CharsToHttpMethod(const char* m) {$/;"	f	namespace:sylar::http
FunctionServlet	servlet.cc	/^FunctionServlet::FunctionServlet(callback cb) $/;"	f	class:sylar::http::FunctionServlet
FunctionServlet	servlet.h	/^class FunctionServlet : public Servlet {$/;"	c	namespace:sylar::http
GetHttpRequestBufferSize	http_parser.cc	/^uint64_t HttpRequestParser::GetHttpRequestBufferSize() {$/;"	f	class:sylar::http::HttpRequestParser
GetHttpRequestMaxBodySize	http_parser.cc	/^uint64_t HttpRequestParser::GetHttpRequestMaxBodySize() {$/;"	f	class:sylar::http::HttpRequestParser
HTTP_METHOD_MAP	http.h	17;"	d
HTTP_STATUS_MAP	http.h	62;"	d
HttpMethod	http.h	/^enum class HttpMethod {$/;"	c	namespace:sylar::http
HttpMethodToString	http.cc	/^const char* HttpMethodToString(const HttpMethod& m) {$/;"	f	namespace:sylar::http
HttpRequest	http.cc	/^HttpRequest::HttpRequest(uint8_t version, bool close)$/;"	f	class:sylar::http::HttpRequest
HttpRequest	http.h	/^class HttpRequest {$/;"	c	namespace:sylar::http
HttpRequestParser	http_parser.cc	/^HttpRequestParser::HttpRequestParser() $/;"	f	class:sylar::http::HttpRequestParser
HttpRequestParser	http_parser.h	/^class HttpRequestParser {$/;"	c	namespace:sylar::http
HttpResponse	http.cc	/^HttpResponse::HttpResponse(uint8_t version, bool close) $/;"	f	class:sylar::http::HttpResponse
HttpResponse	http.h	/^class HttpResponse {$/;"	c	namespace:sylar::http
HttpResponseParser	http_parser.cc	/^HttpResponseParser::HttpResponseParser()$/;"	f	class:sylar::http::HttpResponseParser
HttpResponseParser	http_parser.h	/^class HttpResponseParser  {$/;"	c	namespace:sylar::http
HttpServer	http_server.cc	/^HttpServer::HttpServer(bool keepalive$/;"	f	class:sylar::http::HttpServer
HttpServer	http_server.h	/^class HttpServer : public TcpServer {$/;"	c	namespace:sylar::http
HttpSession	http_session.cc	/^HttpSession::HttpSession(Socket::ptr sock, bool owner)$/;"	f	class:sylar::http::HttpSession
HttpSession	http_session.h	/^class HttpSession : public SocketStream {$/;"	c	namespace:sylar::http
HttpStatus	http.h	/^enum class HttpStatus {$/;"	c	namespace:sylar::http
HttpStatusToString	http.cc	/^const char* HttpStatusToString(const HttpStatus& s) {$/;"	f	namespace:sylar::http
LEN	http11_parser.cc	45;"	d	file:
LEN	httpclient_parser.cc	46;"	d	file:
MARK	http11_parser.cc	46;"	d	file:
MARK	httpclient_parser.cc	47;"	d	file:
MapType	http.h	/^	typedef std::map<std::string, std::string, CaseInsensitiveLess> MapType;$/;"	t	class:sylar::http::HttpRequest
MapType	http.h	/^	typedef std::map<std::string, std::string, CaseInsensitiveLess> MapType;$/;"	t	class:sylar::http::HttpResponse
NotFoundServlet	servlet.cc	/^NotFoundServlet::NotFoundServlet() $/;"	f	class:sylar::http::NotFoundServlet
NotFoundServlet	servlet.h	/^class NotFoundServlet : public Servlet {$/;"	c	namespace:sylar::http
PTR_TO	http11_parser.cc	47;"	d	file:
PTR_TO	httpclient_parser.cc	48;"	d	file:
RWMutexType	servlet.h	/^	typedef RWMutex RWMutexType;$/;"	t	class:sylar::http::ServletDispatch
Servlet	servlet.h	/^	Servlet(const std::string& name)$/;"	f	class:sylar::http::Servlet
Servlet	servlet.h	/^class Servlet {$/;"	c	namespace:sylar::http
ServletDispatch	servlet.cc	/^ServletDispatch::ServletDispatch() $/;"	f	class:sylar::http::ServletDispatch
ServletDispatch	servlet.h	/^class ServletDispatch : public Servlet {$/;"	c	namespace:sylar::http
StringTOHttpMethod	http.cc	/^HttpMethod StringTOHttpMethod(const std::string& m) {$/;"	f	namespace:sylar::http
XX	http.cc	13;"	d	file:
XX	http.cc	18;"	d	file:
XX	http.cc	23;"	d	file:
XX	http.cc	28;"	d	file:
XX	http.cc	30;"	d	file:
XX	http.cc	42;"	d	file:
XX	http.cc	46;"	d	file:
XX	http.cc	8;"	d	file:
XX	http.h	124;"	d
XX	http.h	126;"	d
XX	http.h	131;"	d
XX	http.h	133;"	d
_RequestSizeIniter	http_parser.cc	/^	_RequestSizeIniter() {$/;"	f	struct:sylar::http::__anon1::_RequestSizeIniter
_RequestSizeIniter	http_parser.cc	/^struct _RequestSizeIniter {$/;"	s	namespace:sylar::http::__anon1	file:
__SYLAR_HTTP_HTTP_H__	http.h	2;"	d
__SYLAR_HTTP_HTTP_SERVER_H__	http_server.h	2;"	d
__SYLAR_HTTP_PARSER_H__	http_parser.h	2;"	d
__SYLAR_HTTP_SERVLET_H__	servlet.h	2;"	d
__SYLAR_HTTP_SESSION_H__	http_session.h	2;"	d
_http11_common_h	http11_common.h	2;"	d
_init	http_parser.cc	/^static _RequestSizeIniter _init;$/;"	m	namespace:sylar::http::__anon1	file:
addGlobServlet	servlet.cc	/^void ServletDispatch::addGlobServlet(const std::string& uri$/;"	f	class:sylar::http::ServletDispatch
addGlobServlet	servlet.cc	/^void ServletDispatch::addGlobServlet(const std::string& uri, FunctionServlet::callback cb) {$/;"	f	class:sylar::http::ServletDispatch
addServlet	servlet.cc	/^void ServletDispatch::addServlet(const std::string& uri$/;"	f	class:sylar::http::ServletDispatch
body_start	http11_parser.h	/^  size_t body_start;$/;"	m	struct:http_parser
body_start	httpclient_parser.h	/^  size_t body_start;$/;"	m	struct:httpclient_parser
callback	servlet.h	/^						,HttpSession::ptr session)> callback;$/;"	t	class:sylar::http::FunctionServlet
check	httpclient_parser.cc	49;"	d	file:
checkGetAs	http.h	/^bool checkGetAs(const MapType& m, const std::string& key, T& val, const T& def = T()) {$/;"	f	namespace:sylar::http
checkGetCookiesAs	http.h	/^	bool checkGetCookiesAs(const std::string& key, T& val, const T& def = T()) {$/;"	f	class:sylar::http::HttpRequest
checkGetHeaderAs	http.h	/^	bool checkGetHeaderAs(const std::string& key, T& val, const T& def = T()) {$/;"	f	class:sylar::http::HttpRequest
checkGetHeaderAs	http.h	/^	bool checkGetHeaderAs(const std::string& key, T& val, const T& def = T()) {$/;"	f	class:sylar::http::HttpResponse
checkGetParamAs	http.h	/^	bool checkGetParamAs(const std::string& key, T& val, const T& def = T()) {$/;"	f	class:sylar::http::HttpRequest
chunk_size	httpclient_parser.h	/^  element_cb chunk_size;$/;"	m	struct:httpclient_parser
chunked	httpclient_parser.h	/^  int chunked;$/;"	m	struct:httpclient_parser
chunks_done	httpclient_parser.h	/^  int chunks_done;$/;"	m	struct:httpclient_parser
close	httpclient_parser.h	/^  int close;$/;"	m	struct:httpclient_parser
content_len	http11_parser.h	/^  int content_len;$/;"	m	struct:http_parser
content_len	httpclient_parser.h	/^  int content_len;$/;"	m	struct:httpclient_parser
cs	http11_parser.h	/^  int cs;$/;"	m	struct:http_parser
cs	httpclient_parser.h	/^  int cs;$/;"	m	struct:httpclient_parser
data	http11_parser.h	/^  void *data;$/;"	m	struct:http_parser
data	httpclient_parser.h	/^  void *data;$/;"	m	struct:httpclient_parser
delCookie	http.cc	/^void HttpRequest::delCookie(const std::string& key) {$/;"	f	class:sylar::http::HttpRequest
delGlobServlet	servlet.cc	/^void ServletDispatch::delGlobServlet(const std::string& uri) {$/;"	f	class:sylar::http::ServletDispatch
delHeader	http.cc	/^void HttpRequest::delHeader(const std::string& key) {$/;"	f	class:sylar::http::HttpRequest
delHeader	http.cc	/^void HttpResponse::delHeader(const std::string& key) {$/;"	f	class:sylar::http::HttpResponse
delParam	http.cc	/^void HttpRequest::delParam(const std::string& key) {$/;"	f	class:sylar::http::HttpRequest
delServlet	servlet.cc	/^void ServletDispatch::delServlet(const std::string& uri) {$/;"	f	class:sylar::http::ServletDispatch
dump	http.cc	/^std::ostream& HttpRequest::dump(std::ostream& os) const {$/;"	f	class:sylar::http::HttpRequest
dump	http.cc	/^std::ostream& HttpResponse::dump(std::ostream& os) const {$/;"	f	class:sylar::http::HttpResponse
element_cb	http11_common.h	/^typedef void (*element_cb)(void *data, const char *at, size_t length);$/;"	t
execute	http_parser.cc	/^size_t HttpRequestParser::execute(char* data, size_t len) {$/;"	f	class:sylar::http::HttpRequestParser
execute	http_parser.cc	/^size_t HttpResponseParser::execute(char* data, size_t len) {$/;"	f	class:sylar::http::HttpResponseParser
field_cb	http11_common.h	/^typedef void (*field_cb)(void *data, const char *field, size_t flen, const char *value, size_t vlen);$/;"	t
field_len	http11_parser.h	/^  size_t field_len;$/;"	m	struct:http_parser
field_len	httpclient_parser.h	/^  size_t field_len;$/;"	m	struct:httpclient_parser
field_start	http11_parser.h	/^  size_t field_start;$/;"	m	struct:http_parser
field_start	httpclient_parser.h	/^  size_t field_start;$/;"	m	struct:httpclient_parser
fragment	http11_parser.h	/^  element_cb fragment;$/;"	m	struct:http_parser
g_http_request_buffer_size	http_parser.cc	/^static sylar::ConfigVar<uint64_t>::ptr g_http_request_buffer_size = $/;"	m	namespace:sylar::http	file:
g_http_requesta_max_body_size	http_parser.cc	/^static sylar::ConfigVar<uint64_t>::ptr g_http_requesta_max_body_size = $/;"	m	namespace:sylar::http	file:
g_logger	http_parser.cc	/^static sylar::Logger::ptr g_logger = SYLAR_LOG_NAME("system");$/;"	m	namespace:sylar::http	file:
g_logger	http_server.cc	/^static sylar::Logger::ptr g_logger = SYLAR_LOG_NAME("system");$/;"	m	namespace:sylar::http	file:
getAs	http.h	/^T getAs(const MapType& m, const std::string& key, const T& def = T()) {$/;"	f	namespace:sylar::http
getBody	http.h	/^	const std::string& getBody() const { return m_body; } $/;"	f	class:sylar::http::HttpRequest
getBody	http.h	/^	const std::string& getBody() const { return m_body; }$/;"	f	class:sylar::http::HttpResponse
getContentLength	http_parser.cc	/^uint64_t HttpRequestParser::getContentLength() {$/;"	f	class:sylar::http::HttpRequestParser
getContentLength	http_parser.cc	/^uint64_t HttpResponseParser::getContentLength() {$/;"	f	class:sylar::http::HttpResponseParser
getCookie	http.cc	/^std::string HttpRequest::getCookie(const std::string& key$/;"	f	class:sylar::http::HttpRequest
getCookies	http.h	/^	const MapType& getCookies() const {return m_cookie; }$/;"	f	class:sylar::http::HttpRequest
getCookiesAs	http.h	/^	T getCookiesAs(const std::string& key, const T& def = T()) {$/;"	f	class:sylar::http::HttpRequest
getData	http_parser.h	/^	HttpRequest::ptr getData() const { return m_data; }$/;"	f	class:sylar::http::HttpRequestParser
getData	http_parser.h	/^	HttpResponse::ptr getData() const { return m_data; }$/;"	f	class:sylar::http::HttpResponseParser
getDefault	servlet.h	/^	Servlet::ptr getDefault() const { return m_default; }$/;"	f	class:sylar::http::ServletDispatch
getGlobServlet	servlet.cc	/^Servlet::ptr ServletDispatch::getGlobServlet(const std::string& uri) {$/;"	f	class:sylar::http::ServletDispatch
getHeader	http.cc	/^std::string HttpRequest::getHeader(const std::string& key$/;"	f	class:sylar::http::HttpRequest
getHeader	http.cc	/^std::string HttpResponse::getHeader(const std::string& key, const std::string& def) const {$/;"	f	class:sylar::http::HttpResponse
getHeaderAs	http.h	/^	T getHeaderAs(const std::string& key, const T& def = T()) {$/;"	f	class:sylar::http::HttpRequest
getHeaderAs	http.h	/^	T getHeaderAs(const std::string& key, const T& def = T()) {$/;"	f	class:sylar::http::HttpResponse
getHeaders	http.h	/^	const MapType& getHeaders() const { return m_headers; }$/;"	f	class:sylar::http::HttpResponse
getHeaders	http.h	/^	const MapType& getHeaders() const {return m_headers; }$/;"	f	class:sylar::http::HttpRequest
getMatchedServlet	servlet.cc	/^Servlet::ptr ServletDispatch::getMatchedServlet(const std::string& uri) {$/;"	f	class:sylar::http::ServletDispatch
getMethod	http.h	/^	HttpMethod getMethod() const { return m_method; }$/;"	f	class:sylar::http::HttpRequest
getName	servlet.h	/^	const std::string getName() const { return m_name; }$/;"	f	class:sylar::http::Servlet
getParam	http.cc	/^std::string HttpRequest::getParam(const std::string& key$/;"	f	class:sylar::http::HttpRequest
getParamAs	http.h	/^	T getParamAs(const std::string& key, const T& def = T()) {$/;"	f	class:sylar::http::HttpRequest
getParams	http.h	/^	const MapType& getParams() const {return m_params; }$/;"	f	class:sylar::http::HttpRequest
getPath	http.h	/^	const std::string& getPath() const { return m_path; }$/;"	f	class:sylar::http::HttpRequest
getQuery	http.h	/^	const std::string& getQuery() const { return m_query; }$/;"	f	class:sylar::http::HttpRequest
getReason	http.h	/^	const std::string& getReason() const { return m_reason; }$/;"	f	class:sylar::http::HttpResponse
getServlet	servlet.cc	/^Servlet::ptr ServletDispatch::getServlet(const std::string& uri) {$/;"	f	class:sylar::http::ServletDispatch
getServletDispatch	http_server.h	/^	ServletDispatch::ptr getServletDispatch() const { return m_dispatch; }$/;"	f	class:sylar::http::HttpServer
getStatus	http.h	/^	HttpStatus getStatus() const { return m_status; }$/;"	f	class:sylar::http::HttpResponse
getVersion	http.h	/^	uint8_t getVersion() const { return m_version; }$/;"	f	class:sylar::http::HttpRequest
getVersion	http.h	/^	uint8_t getVersion() const { return m_version; }$/;"	f	class:sylar::http::HttpResponse
handle	servlet.cc	/^int32_t FunctionServlet::handle(sylar::http::HttpRequest::ptr request$/;"	f	class:sylar::http::FunctionServlet
handle	servlet.cc	/^int32_t NotFoundServlet::handle(sylar::http::HttpRequest::ptr request$/;"	f	class:sylar::http::NotFoundServlet
handle	servlet.cc	/^int32_t ServletDispatch::handle(sylar::http::HttpRequest::ptr request$/;"	f	class:sylar::http::ServletDispatch
handleClient	http_server.cc	/^void HttpServer::handleClient(Socket::ptr client) {$/;"	f	class:sylar::http::HttpServer
hasCookie	http.cc	/^bool HttpRequest::hasCookie(const std::string& key, std::string* val) {$/;"	f	class:sylar::http::HttpRequest
hasError	http_parser.cc	/^int HttpRequestParser::hasError() {$/;"	f	class:sylar::http::HttpRequestParser
hasError	http_parser.cc	/^int HttpResponseParser::hasError() {$/;"	f	class:sylar::http::HttpResponseParser
hasHeader	http.cc	/^bool HttpRequest::hasHeader(const std::string& key, std::string* val) {$/;"	f	class:sylar::http::HttpRequest
hasParam	http.cc	/^bool HttpRequest::hasParam(const std::string& key, std::string* val) {$/;"	f	class:sylar::http::HttpRequest
header_done	http11_parser.h	/^  element_cb header_done;$/;"	m	struct:http_parser
header_done	httpclient_parser.h	/^  element_cb header_done;$/;"	m	struct:httpclient_parser
http	http.cc	/^namespace http{$/;"	n	namespace:sylar	file:
http	http.h	/^namespace http{$/;"	n	namespace:sylar
http	http_parser.cc	/^namespace http {$/;"	n	namespace:sylar	file:
http	http_parser.h	/^namespace http {$/;"	n	namespace:sylar
http	http_server.cc	/^namespace http {$/;"	n	namespace:sylar	file:
http	http_server.h	/^namespace http {$/;"	n	namespace:sylar
http	http_session.cc	/^namespace http {$/;"	n	namespace:sylar	file:
http	http_session.h	/^namespace http {$/;"	n	namespace:sylar
http	servlet.cc	/^namespace http {$/;"	n	namespace:sylar	file:
http	servlet.h	/^namespace http {$/;"	n	namespace:sylar
http11_parser_h	http11_parser.h	2;"	d
http_field	http11_parser.h	/^  field_cb http_field;$/;"	m	struct:http_parser
http_field	httpclient_parser.h	/^  field_cb http_field;$/;"	m	struct:httpclient_parser
http_parser	http11_parser.h	/^typedef struct http_parser { $/;"	s
http_parser	http11_parser.h	/^} http_parser;$/;"	t	typeref:struct:http_parser
http_parser_en_main	http11_parser.cc	/^static const int http_parser_en_main = 1;$/;"	v	file:
http_parser_error	http11_parser.cc	/^static const int http_parser_error = 0;$/;"	v	file:
http_parser_execute	http11_parser.cc	/^size_t http_parser_execute(http_parser *parser, const char *buffer, size_t len, size_t off)  $/;"	f
http_parser_finish	http11_parser.cc	/^int http_parser_finish(http_parser *parser)$/;"	f
http_parser_first_final	http11_parser.cc	/^static const int http_parser_first_final = 348;$/;"	v	file:
http_parser_has_error	http11_parser.cc	/^int http_parser_has_error(http_parser *parser) {$/;"	f
http_parser_init	http11_parser.cc	/^int http_parser_init(http_parser *parser) {$/;"	f
http_parser_is_finished	http11_parser.cc	/^int http_parser_is_finished(http_parser *parser) {$/;"	f
http_parser_nread	http11_parser.h	38;"	d
http_parser_start	http11_parser.cc	/^static const int http_parser_start = 1;$/;"	v	file:
http_version	http11_parser.h	/^  element_cb http_version;$/;"	m	struct:http_parser
http_version	httpclient_parser.h	/^  element_cb http_version;$/;"	m	struct:httpclient_parser
httpclient_parser	httpclient_parser.h	/^typedef struct httpclient_parser { $/;"	s
httpclient_parser	httpclient_parser.h	/^} httpclient_parser;$/;"	t	typeref:struct:httpclient_parser
httpclient_parser_en_main	httpclient_parser.cc	/^static const int httpclient_parser_en_main = 1;$/;"	v	file:
httpclient_parser_error	httpclient_parser.cc	/^static const int httpclient_parser_error = 0;$/;"	v	file:
httpclient_parser_execute	httpclient_parser.cc	/^int httpclient_parser_execute(httpclient_parser *parser, const char *buffer, size_t len, size_t off)  $/;"	f
httpclient_parser_finish	httpclient_parser.cc	/^int httpclient_parser_finish(httpclient_parser *parser)$/;"	f
httpclient_parser_first_final	httpclient_parser.cc	/^static const int httpclient_parser_first_final = 120;$/;"	v	file:
httpclient_parser_h	httpclient_parser.h	36;"	d
httpclient_parser_has_error	httpclient_parser.cc	/^int httpclient_parser_has_error(httpclient_parser *parser) {$/;"	f
httpclient_parser_init	httpclient_parser.cc	/^int httpclient_parser_init(httpclient_parser *parser)  {$/;"	f
httpclient_parser_is_finished	httpclient_parser.cc	/^int httpclient_parser_is_finished(httpclient_parser *parser) {$/;"	f
httpclient_parser_nread	httpclient_parser.h	72;"	d
httpclient_parser_start	httpclient_parser.cc	/^static const int httpclient_parser_start = 1;$/;"	v	file:
isClose	http.h	/^	bool isClose() const { return m_close; }$/;"	f	class:sylar::http::HttpRequest
isClose	http.h	/^	bool isClose() const { return m_close; }$/;"	f	class:sylar::http::HttpResponse
isFinished	http_parser.cc	/^int HttpRequestParser::isFinished() {$/;"	f	class:sylar::http::HttpRequestParser
isFinished	http_parser.cc	/^int HttpResponseParser::isFinished() {$/;"	f	class:sylar::http::HttpResponseParser
json_sent	http11_parser.h	/^  int json_sent;$/;"	m	struct:http_parser
last_chunk	httpclient_parser.h	/^  element_cb last_chunk;$/;"	m	struct:httpclient_parser
m_body	http.h	/^	std::string m_body;$/;"	m	class:sylar::http::HttpRequest
m_body	http.h	/^	std::string m_body;$/;"	m	class:sylar::http::HttpResponse
m_cb	servlet.h	/^	callback m_cb;$/;"	m	class:sylar::http::FunctionServlet
m_close	http.h	/^	bool m_close;$/;"	m	class:sylar::http::HttpRequest
m_close	http.h	/^	bool m_close;$/;"	m	class:sylar::http::HttpResponse
m_cookie	http.h	/^	MapType m_cookie;$/;"	m	class:sylar::http::HttpRequest
m_data	http_parser.h	/^	HttpRequest::ptr m_data;$/;"	m	class:sylar::http::HttpRequestParser
m_data	http_parser.h	/^	HttpResponse::ptr m_data;$/;"	m	class:sylar::http::HttpResponseParser
m_datas	servlet.h	/^	std::unordered_map<std::string, Servlet::ptr> m_datas;$/;"	m	class:sylar::http::ServletDispatch
m_default	servlet.h	/^	Servlet::ptr m_default;$/;"	m	class:sylar::http::ServletDispatch
m_dispatch	http_server.h	/^	ServletDispatch::ptr m_dispatch;$/;"	m	class:sylar::http::HttpServer
m_error	http_parser.h	/^	int m_error;$/;"	m	class:sylar::http::HttpRequestParser
m_error	http_parser.h	/^	int m_error;$/;"	m	class:sylar::http::HttpResponseParser
m_fregment	http.h	/^	std::string m_fregment;$/;"	m	class:sylar::http::HttpRequest
m_globs	servlet.h	/^	std::vector<std::pair<std::string, Servlet::ptr>> m_globs;$/;"	m	class:sylar::http::ServletDispatch
m_headers	http.h	/^	MapType m_headers;$/;"	m	class:sylar::http::HttpRequest
m_headers	http.h	/^	MapType m_headers;$/;"	m	class:sylar::http::HttpResponse
m_isKeepalive	http_server.h	/^	bool m_isKeepalive;$/;"	m	class:sylar::http::HttpServer
m_method	http.h	/^	HttpMethod m_method;$/;"	m	class:sylar::http::HttpRequest
m_mutex	servlet.h	/^	RWMutexType m_mutex;$/;"	m	class:sylar::http::ServletDispatch
m_name	servlet.h	/^	std::string m_name;$/;"	m	class:sylar::http::Servlet
m_params	http.h	/^	MapType m_params;$/;"	m	class:sylar::http::HttpRequest
m_parser	http_parser.h	/^	http_parser m_parser;$/;"	m	class:sylar::http::HttpRequestParser
m_parser	http_parser.h	/^	httpclient_parser m_parser;$/;"	m	class:sylar::http::HttpResponseParser
m_path	http.h	/^	std::string m_path;$/;"	m	class:sylar::http::HttpRequest
m_query	http.h	/^	std::string m_query;$/;"	m	class:sylar::http::HttpRequest
m_reason	http.h	/^	std::string m_reason;$/;"	m	class:sylar::http::HttpResponse
m_status	http.h	/^	HttpStatus m_status;$/;"	m	class:sylar::http::HttpResponse
m_version	http.h	/^	uint8_t m_version;$/;"	m	class:sylar::http::HttpRequest
m_version	http.h	/^	uint8_t m_version;$/;"	m	class:sylar::http::HttpResponse
mark	http11_parser.h	/^  size_t mark;$/;"	m	struct:http_parser
mark	httpclient_parser.h	/^  size_t mark;$/;"	m	struct:httpclient_parser
nread	http11_parser.h	/^  size_t nread;$/;"	m	struct:http_parser
nread	httpclient_parser.h	/^  size_t nread;$/;"	m	struct:httpclient_parser
on_request_fragment	http_parser.cc	/^void on_request_fragment(void *data, const char* at, size_t length) {$/;"	f	namespace:sylar::http
on_request_header_done	http_parser.cc	/^void on_request_header_done(void *data, const char* at, size_t length) {$/;"	f	namespace:sylar::http
on_request_http_field	http_parser.cc	/^void on_request_http_field(void *data, const char* field, size_t flen$/;"	f	namespace:sylar::http
on_request_method	http_parser.cc	/^void on_request_method(void *data, const char* at, size_t length) {$/;"	f	namespace:sylar::http
on_request_path	http_parser.cc	/^void on_request_path(void *data, const char* at, size_t length) {$/;"	f	namespace:sylar::http
on_request_query	http_parser.cc	/^void on_request_query(void *data, const char* at, size_t length) {$/;"	f	namespace:sylar::http
on_request_uri	http_parser.cc	/^void on_request_uri(void *data, const char* at, size_t length) {$/;"	f	namespace:sylar::http
on_request_version	http_parser.cc	/^void on_request_version(void *data, const char* at, size_t length) {$/;"	f	namespace:sylar::http
on_response_chunk	http_parser.cc	/^void on_response_chunk(void* data, const char* at, size_t length) {$/;"	f	namespace:sylar::http
on_response_header_done	http_parser.cc	/^void on_response_header_done(void* data, const char* at, size_t length) {$/;"	f	namespace:sylar::http
on_response_http_field	http_parser.cc	/^void on_response_http_field(void* data, const char* field, size_t flen$/;"	f	namespace:sylar::http
on_response_last_chunk	http_parser.cc	/^void on_response_last_chunk(void* data, const char* at, size_t length) {$/;"	f	namespace:sylar::http
on_response_reason	http_parser.cc	/^void on_response_reason(void* data, const char* at, size_t length) {$/;"	f	namespace:sylar::http
on_response_status	http_parser.cc	/^void on_response_status(void* data, const char* at, size_t length) {$/;"	f	namespace:sylar::http
on_response_version	http_parser.cc	/^void on_response_version(void* data, const char* at, size_t length) {$/;"	f	namespace:sylar::http
operator ()	http.cc	/^bool CaseInsensitiveLess::operator()(const std::string& lhs, const std::string& rhs) const {$/;"	f	class:sylar::http::CaseInsensitiveLess
operator <<	http.cc	/^std::ostream& operator<<(std::ostream& os, const HttpRequest& req) {$/;"	f	namespace:sylar::http
operator <<	http.cc	/^std::ostream& operator<<(std::ostream& os, const HttpResponse& rsp) {$/;"	f	namespace:sylar::http
override	http_server.h	/^	virtual void handleClient(Socket::ptr client) override;$/;"	m	class:sylar::http::HttpServer
override	servlet.h	/^			,sylar::http::HttpSession::ptr session) override;$/;"	m	class:sylar::http::FunctionServlet
override	servlet.h	/^			,sylar::http::HttpSession::ptr session) override;$/;"	m	class:sylar::http::NotFoundServlet
override	servlet.h	/^			,sylar::http::HttpSession::ptr session) override;$/;"	m	class:sylar::http::ServletDispatch
ptr	http.h	/^	typedef std::shared_ptr<HttpRequest> ptr;$/;"	t	class:sylar::http::HttpRequest
ptr	http.h	/^	typedef std::shared_ptr<HttpResponse> ptr;$/;"	t	class:sylar::http::HttpResponse
ptr	http_parser.h	/^	typedef std::shared_ptr<HttpRequestParser> ptr;$/;"	t	class:sylar::http::HttpRequestParser
ptr	http_parser.h	/^	typedef std::shared_ptr<HttpResponseParser> ptr;$/;"	t	class:sylar::http::HttpResponseParser
ptr	http_server.h	/^	typedef std::shared_ptr<HttpServer> ptr;$/;"	t	class:sylar::http::HttpServer
ptr	http_session.h	/^	typedef std::shared_ptr<HttpSession> ptr;$/;"	t	class:sylar::http::HttpSession
ptr	servlet.h	/^	typedef std::shared_ptr<FunctionServlet> ptr;$/;"	t	class:sylar::http::FunctionServlet
ptr	servlet.h	/^	typedef std::shared_ptr<NotFoundServlet> ptr;$/;"	t	class:sylar::http::NotFoundServlet
ptr	servlet.h	/^	typedef std::shared_ptr<Servlet> ptr;$/;"	t	class:sylar::http::Servlet
ptr	servlet.h	/^	typedef std::shared_ptr<ServletDispatch> ptr;$/;"	t	class:sylar::http::ServletDispatch
query_start	http11_parser.h	/^  size_t query_start;$/;"	m	struct:http_parser
query_string	http11_parser.h	/^  element_cb query_string;$/;"	m	struct:http_parser
reason_phrase	httpclient_parser.h	/^  element_cb reason_phrase;$/;"	m	struct:httpclient_parser
recvRequsest	http_session.cc	/^HttpRequest::ptr HttpSession::recvRequsest() {$/;"	f	class:sylar::http::HttpSession
request_method	http11_parser.h	/^  element_cb request_method;$/;"	m	struct:http_parser
request_path	http11_parser.h	/^  element_cb request_path;$/;"	m	struct:http_parser
request_uri	http11_parser.h	/^  element_cb request_uri;$/;"	m	struct:http_parser
s_http_request_bufer_size	http_parser.cc	/^static uint64_t s_http_request_bufer_size  = 0;$/;"	m	namespace:sylar::http	file:
s_http_requesta_max_body_size	http_parser.cc	/^static uint64_t s_http_requesta_max_body_size = 0;$/;"	m	namespace:sylar::http	file:
s_method_string	http.cc	/^static const char* s_method_string[] = {$/;"	m	namespace:sylar::http	file:
sendRespons	http_session.cc	/^int HttpSession::sendRespons(HttpResponse::ptr rsp) {$/;"	f	class:sylar::http::HttpSession
setBody	http.h	/^	void setBody(const std::string& v) { m_body = v; }$/;"	f	class:sylar::http::HttpRequest
setBody	http.h	/^	void setBody(const std::string& v) { m_body = v; }$/;"	f	class:sylar::http::HttpResponse
setClose	http.h	/^	void setClose(bool v) { m_close = v; }$/;"	f	class:sylar::http::HttpRequest
setClose	http.h	/^	void setClose(bool v) { m_close = v; }$/;"	f	class:sylar::http::HttpResponse
setCookie	http.cc	/^void HttpRequest::setCookie(const std::string& key, const std::string& val) {$/;"	f	class:sylar::http::HttpRequest
setCookies	http.h	/^	void setCookies(const MapType& v) {m_cookie = v; }$/;"	f	class:sylar::http::HttpRequest
setDefault	servlet.h	/^	void setDefault(Servlet::ptr v) { m_default = v; }$/;"	f	class:sylar::http::ServletDispatch
setError	http_parser.h	/^	void setError(int v) { m_error = v; }$/;"	f	class:sylar::http::HttpRequestParser
setError	http_parser.h	/^	void setError(int v) { m_error = v; }$/;"	f	class:sylar::http::HttpResponseParser
setFragment	http.h	/^	void setFragment(const std::string& v) { m_fregment = v; }$/;"	f	class:sylar::http::HttpRequest
setHeader	http.cc	/^void HttpRequest::setHeader(const std::string& key, const std::string& val) {$/;"	f	class:sylar::http::HttpRequest
setHeader	http.cc	/^void HttpResponse::setHeader(const std::string& key, const std::string& val) {$/;"	f	class:sylar::http::HttpResponse
setHeaders	http.h	/^	void setHeaders(const MapType& v) { m_headers = v; }$/;"	f	class:sylar::http::HttpRequest
setHeaders	http.h	/^	void setHeaders(const MapType& v) { m_headers = v; }$/;"	f	class:sylar::http::HttpResponse
setMethod	http.h	/^	void setMethod(HttpMethod v) { m_method = v; }$/;"	f	class:sylar::http::HttpRequest
setParam	http.cc	/^void HttpRequest::setParam(const std::string& key, const std::string& val) {$/;"	f	class:sylar::http::HttpRequest
setParams	http.h	/^	void setParams(const MapType& v) { m_params = v; }$/;"	f	class:sylar::http::HttpRequest
setPath	http.h	/^	void setPath(const std::string& v) { m_path = v; }$/;"	f	class:sylar::http::HttpRequest
setQuery	http.h	/^	void setQuery(const std::string& v) { m_query = v; }$/;"	f	class:sylar::http::HttpRequest
setReason	http.h	/^	void setReason(const std::string& v) { m_reason = v; }$/;"	f	class:sylar::http::HttpResponse
setServletDispatch	http_server.h	/^	void setServletDispatch(ServletDispatch::ptr v) { m_dispatch = v; }$/;"	f	class:sylar::http::HttpServer
setStatus	http.h	/^	void setStatus(HttpStatus v) { m_status = v; }$/;"	f	class:sylar::http::HttpResponse
setVersion	http.h	/^	void setVersion(uint8_t v) { m_version = v; }$/;"	f	class:sylar::http::HttpRequest
setVersion	http.h	/^	void setVersion(uint8_t v) { m_version = v; }$/;"	f	class:sylar::http::HttpResponse
status	httpclient_parser.h	/^  int status;$/;"	m	struct:httpclient_parser
status_code	httpclient_parser.h	/^  element_cb status_code;$/;"	m	struct:httpclient_parser
sylar	http.cc	/^namespace sylar{$/;"	n	file:
sylar	http.h	/^namespace sylar{$/;"	n
sylar	http_parser.cc	/^namespace sylar {$/;"	n	file:
sylar	http_parser.h	/^namespace sylar {$/;"	n
sylar	http_server.cc	/^namespace sylar {$/;"	n	file:
sylar	http_server.h	/^namespace sylar {$/;"	n
sylar	http_session.cc	/^namespace sylar {$/;"	n	file:
sylar	http_session.h	/^namespace sylar { $/;"	n
sylar	servlet.cc	/^namespace sylar {$/;"	n	file:
sylar	servlet.h	/^namespace sylar {$/;"	n
toString	http.cc	/^std::string HttpRequest::toString() const {$/;"	f	class:sylar::http::HttpRequest
toString	http.cc	/^std::string HttpResponse::toString() const {$/;"	f	class:sylar::http::HttpResponse
uri_relaxed	http11_parser.h	/^  int uri_relaxed;$/;"	m	struct:http_parser
xml_sent	http11_parser.h	/^  int xml_sent;$/;"	m	struct:http_parser
~Servlet	servlet.h	/^	virtual ~Servlet() {}$/;"	f	class:sylar::http::Servlet
